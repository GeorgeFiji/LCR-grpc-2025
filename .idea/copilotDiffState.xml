<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/register_nodes.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/register_nodes.bat" />
              <option name="updatedContent" value="@echo off&#10;REM Author: George Fong&#10;REM Batch file to register all nodes for LCR Leader Election&#10;&#10;REM Example node IDs&#10;set NODE_IDS=5 11 2 7&#10;&#10;REM Path to your compiled classes&#10;set CLASSPATH=target/classes&#10;&#10;REM Start each node in a new window&#10;for %%I in (%NODE_IDS%) do (&#10;    start &quot;Node %%I&quot; java -cp %CLASSPATH% CS324_A2.Node %%I&#10;)&#10;&#10;echo All nodes started!&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/CS324_A2/NodeImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/CS324_A2/NodeImpl.java" />
              <option name="updatedContent" value="// Author: Jone Fong&#10;package CS324_A2;&#10;&#10;import java.rmi.RemoteException;&#10;import java.rmi.server.UnicastRemoteObject;&#10;import java.util.Scanner;&#10;&#10;public class NodeImpl extends UnicastRemoteObject implements NodeInterface {&#10;    private final int nodeId;&#10;    private NodeInterface nextNode;&#10;    private boolean isLeader = false;&#10;    private int leaderId = -1;&#10;    private boolean leaderAnnounced = false;&#10;&#10;    public NodeImpl(int nodeId) throws RemoteException {&#10;        super();&#10;        this.nodeId = nodeId;&#10;    }&#10;&#10;    @Override&#10;    public void setNextNode(NodeInterface nextNode) throws RemoteException {&#10;        this.nextNode = nextNode;&#10;    }&#10;&#10;    @Override&#10;    public void receiveElection(int candidateId) throws RemoteException {&#10;        if (candidateId == this.nodeId) {&#10;            this.isLeader = true;&#10;            this.leaderId = this.nodeId;&#10;            System.out.println(&quot;Node &quot; + nodeId + &quot; is elected as leader.&quot;);&#10;            if (nextNode != null) nextNode.receiveLeader(this.nodeId);&#10;            return;&#10;        }&#10;        if (candidateId &gt; this.nodeId) {&#10;            if (nextNode != null) nextNode.receiveElection(candidateId);&#10;        }&#10;        // else drop&#10;    }&#10;&#10;    @Override&#10;    public void receiveLeader(int leaderId) throws RemoteException {&#10;        if (this.leaderAnnounced) return;&#10;        this.leaderAnnounced = true;&#10;        this.leaderId = leaderId;&#10;        System.out.println(&quot;Node &quot; + nodeId + &quot; records leader: &quot; + leaderId);&#10;        if (!this.isLeader &amp;&amp; nextNode != null) {&#10;            nextNode.receiveLeader(leaderId);&#10;        }&#10;    }&#10;&#10;    // Simulate user input for starting election&#10;    public void handleUserInput() {&#10;        Scanner scanner = new Scanner(System.in);&#10;        while (true) {&#10;            System.out.println(&quot;Node &quot; + nodeId + &quot;: Enter 'election' to start election or 'exit' to quit:&quot;);&#10;            String input = scanner.nextLine();&#10;            if (input.equalsIgnoreCase(&quot;election&quot;)) {&#10;                try {&#10;                    if (nextNode != null) {&#10;                        nextNode.receiveElection(nodeId);&#10;                        System.out.println(&quot;Node &quot; + nodeId + &quot; started election.&quot;);&#10;                    } else {&#10;                        System.out.println(&quot;No successor node set.&quot;);&#10;                    }&#10;                } catch (RemoteException e) {&#10;                    System.err.println(&quot;Error sending election message: &quot; + e.getMessage());&#10;                }&#10;            } else if (input.equalsIgnoreCase(&quot;exit&quot;)) {&#10;                System.out.println(&quot;Node &quot; + nodeId + &quot; exiting.&quot;);&#10;                break;&#10;            }&#10;        }&#10;        scanner.close();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/CS324_A2/PeerRegisterImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/CS324_A2/PeerRegisterImpl.java" />
              <option name="originalContent" value="package CS324_A2;&#10;&#10;import java.rmi.AlreadyBoundException;&#10;import java.rmi.NotBoundException;&#10;import java.rmi.RemoteException;&#10;import java.rmi.registry.LocateRegistry;&#10;import java.rmi.registry.Registry;&#10;import java.rmi.server.UnicastRemoteObject;&#10;import java.util.ArrayList;&#10;&#10;public class PeerRegisterImpl extends UnicastRemoteObject implements PeerRegister {&#10;    public Registry registry;&#10;    private final ArrayList&lt;Integer&gt; peers;&#10;    private boolean electionInProgress;&#10;    private final Object electionLock;&#10;&#10;    protected PeerRegisterImpl() throws RemoteException {&#10;        this.peers = new ArrayList&lt;&gt;();&#10;        try {&#10;            this.registry = LocateRegistry.getRegistry(Registry.REGISTRY_PORT);&#10;            // Test if registry is alive by listing&#10;            this.registry.list();&#10;        } catch (RemoteException e) {&#10;            // If not running, create a new registry&#10;            this.registry = LocateRegistry.createRegistry(Registry.REGISTRY_PORT);&#10;        }&#10;        this.electionInProgress = false;&#10;        this.electionLock = new Object();&#10;    }&#10;&#10;    @Override&#10;    public synchronized void register(int nodeId) throws RemoteException, NotBoundException {&#10;        synchronized (electionLock) {&#10;            if (electionInProgress) {&#10;                System.out.println(&quot;Node &quot; + nodeId + &quot; blocked - Election is currently in progress&quot;);&#10;                throw new RemoteException(&quot;Cannot register Node &quot; + nodeId + &quot; - Election is currently in progress. Please wait for the election to complete.&quot;);&#10;            }&#10;        }&#10;&#10;        System.out.println(&quot;Attempting to register Node &quot; + nodeId);&#10;&#10;        synchronized (electionLock) {&#10;            if (peers.contains(nodeId)) {&#10;                throw new RemoteException(&quot;Node &quot; + nodeId + &quot; is already registered.&quot;);&#10;            }&#10;&#10;            peers.add(nodeId);&#10;            System.out.println(&quot;Current peers: &quot; + peers);&#10;&#10;            setupRingTopology();&#10;&#10;            System.out.println(&quot;Node &quot; + nodeId + &quot; registered successfully.&quot;);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void notifyElectionStarted(int nodeId) throws RemoteException {&#10;        synchronized (electionLock) {&#10;            if (!electionInProgress) {&#10;                electionInProgress = true;&#10;                System.out.println(&quot;PeerRegister: Election started by Node &quot; + nodeId + &quot; - Registration blocked&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void notifyElectionEnded(int nodeId) throws RemoteException {&#10;        synchronized (electionLock) {&#10;            if (electionInProgress) {&#10;                electionInProgress = false;&#10;                System.out.println(&quot;PeerRegister: Election ended - Registration now allowed&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void setupRingTopology() throws RemoteException, NotBoundException {&#10;        if (peers.size() &lt; 2) {&#10;            return;&#10;        }&#10;        System.out.println(&quot;Setting up ring topology for peers: &quot; + peers);&#10;        for (int i = 0; i &lt; peers.size(); i++) {&#10;            int currentNodeId = peers.get(i);&#10;            int nextNodeId = peers.get((i + 1) % peers.size());&#10;            NodeInterface currentNodeInterface = (NodeInterface) registry.lookup(&quot;Node&quot; + currentNodeId);&#10;            NodeInterface nextNodeInterface = (NodeInterface) registry.lookup(&quot;Node&quot; + nextNodeId);&#10;            currentNodeInterface.setNextNode(nextNodeInterface);&#10;            System.out.println(&quot;Connected Node &quot; + currentNodeId + &quot; -&gt; Node &quot; + nextNodeId);&#10;        }&#10;        System.out.println(&quot;Ring topology setup complete.&quot;);&#10;    }&#10;&#10;    public static void main(String[] args) throws RemoteException {&#10;        System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;localhost&quot;);&#10;        try {&#10;            PeerRegisterImpl peerRegister = new PeerRegisterImpl();&#10;            peerRegister.registry.bind(&quot;PeerRegister&quot;, peerRegister);&#10;            System.out.println(&quot;Peer register node running on port &quot; + Registry.REGISTRY_PORT + &quot; ...&quot;);&#10;            System.out.println(&quot;Ready to accept node registrations.&quot;);&#10;            Thread.currentThread().join();&#10;        } catch (AlreadyBoundException e) {&#10;            System.err.println(&quot;Peer register is already bound.&quot;);&#10;        } catch (InterruptedException e) {&#10;            System.err.println(&quot;Interrupted while waiting.&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package CS324_A2;&#10;&#10;import java.rmi.AlreadyBoundException;&#10;import java.rmi.NotBoundException;&#10;import java.rmi.RemoteException;&#10;import java.rmi.registry.LocateRegistry;&#10;import java.rmi.registry.Registry;&#10;import java.rmi.server.UnicastRemoteObject;&#10;import java.util.ArrayList;&#10;&#10;public class PeerRegisterImpl extends UnicastRemoteObject implements PeerRegister {&#10;    public Registry registry;&#10;    private final ArrayList&lt;Integer&gt; peers;&#10;    private boolean electionInProgress;&#10;    private final Object electionLock;&#10;&#10;    protected PeerRegisterImpl() throws RemoteException {&#10;        this.peers = new ArrayList&lt;&gt;();&#10;        this.registry = LocateRegistry.getRegistry(Registry.REGISTRY_PORT);&#10;        this.electionInProgress = false;&#10;        this.electionLock = new Object();&#10;    }&#10;&#10;    @Override&#10;    public synchronized void register(int nodeId) throws RemoteException, NotBoundException {&#10;        synchronized (electionLock) {&#10;            if (electionInProgress) {&#10;                System.out.println(&quot;Node &quot; + nodeId + &quot; blocked - Election is currently in progress&quot;);&#10;                throw new RemoteException(&quot;Cannot register Node &quot; + nodeId + &quot; - Election is currently in progress. Please wait for the election to complete.&quot;);&#10;            }&#10;        }&#10;&#10;        System.out.println(&quot;Attempting to register Node &quot; + nodeId);&#10;&#10;        synchronized (electionLock) {&#10;            if (peers.contains(nodeId)) {&#10;                throw new RemoteException(&quot;Node &quot; + nodeId + &quot; is already registered.&quot;);&#10;            }&#10;&#10;            peers.add(nodeId);&#10;            System.out.println(&quot;Current peers: &quot; + peers);&#10;&#10;            setupRingTopology();&#10;&#10;            System.out.println(&quot;Node &quot; + nodeId + &quot; registered successfully.&quot;);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void notifyElectionStarted(int nodeId) throws RemoteException {&#10;        synchronized (electionLock) {&#10;            if (!electionInProgress) {&#10;                electionInProgress = true;&#10;                System.out.println(&quot;PeerRegister: Election started by Node &quot; + nodeId + &quot; - Registration blocked&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void notifyElectionEnded(int nodeId) throws RemoteException {&#10;        synchronized (electionLock) {&#10;            if (electionInProgress) {&#10;                electionInProgress = false;&#10;                System.out.println(&quot;PeerRegister: Election ended - Registration now allowed&quot;);&#10;            }&#10;        }&#10;    }&#10;&#10;    private void setupRingTopology() throws RemoteException, NotBoundException {&#10;        if (peers.size() &lt; 2) {&#10;            return;&#10;        }&#10;        System.out.println(&quot;Setting up ring topology for peers: &quot; + peers);&#10;        for (int i = 0; i &lt; peers.size(); i++) {&#10;            int currentNodeId = peers.get(i);&#10;            int nextNodeId = peers.get((i + 1) % peers.size());&#10;            NodeInterface currentNodeInterface = (NodeInterface) registry.lookup(&quot;Node&quot; + currentNodeId);&#10;            NodeInterface nextNodeInterface = (NodeInterface) registry.lookup(&quot;Node&quot; + nextNodeId);&#10;            currentNodeInterface.setNextNode(nextNodeInterface);&#10;            System.out.println(&quot;Connected Node &quot; + currentNodeId + &quot; -&gt; Node &quot; + nextNodeId);&#10;        }&#10;        System.out.println(&quot;Ring topology setup complete.&quot;);&#10;    }&#10;&#10;    public static void main(String[] args) throws RemoteException {&#10;        System.setProperty(&quot;java.rmi.server.hostname&quot;, &quot;localhost&quot;);&#10;        try {&#10;            PeerRegisterImpl peerRegister = new PeerRegisterImpl();&#10;            peerRegister.registry.bind(&quot;PeerRegister&quot;, peerRegister);&#10;            System.out.println(&quot;Peer register node running on port &quot; + Registry.REGISTRY_PORT + &quot; ...&quot;);&#10;            System.out.println(&quot;Ready to accept node registrations.&quot;);&#10;            Thread.currentThread().join();&#10;        } catch (AlreadyBoundException e) {&#10;            System.err.println(&quot;Peer register is already bound.&quot;);&#10;        } catch (InterruptedException e) {&#10;            System.err.println(&quot;Interrupted while waiting.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>